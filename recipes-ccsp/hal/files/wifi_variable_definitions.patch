--- git_old/source/wifi/devices/include/wifi_hal.h	2021-05-17 07:29:12.289101985 +0000
+++ git/source/wifi/devices/include/wifi_hal.h	2021-05-17 07:43:36.374622903 +0000
@@ -89,6 +89,10 @@
 #define ULONG unsigned long
 #endif
 
+#ifndef USHORT
+#define USHORT unsigned short
+#endif
+
 #ifndef BOOL
 #define BOOL  unsigned char
 #endif
@@ -159,11 +163,19 @@
 #define WIFI_HAL_MINOR_VERSION 2   // This is the minor verson of the HAL.
 #define WIFI_HAL_MAINTENANCE_VERSION 2   // This is the maintenance version of the HAL.
 
+// 802.11v BSS Transition Management Definitions
+
+#define MAX_URL_LEN         512
+#define MAX_CANDIDATES      64
+#define MAX_VENDOR_SPECIFIC 32
+
 /**********************************************************************
                 STRUCTURE DEFINITIONS
 **********************************************************************/
 
 typedef unsigned char mac_address_t[6];
+typedef mac_address_t   bssid_t;
+typedef char            ssid_t[32];
 
 //>> Deprecated: used for old RDKB code. 
 typedef struct _wifi_basicTrafficStats
@@ -5505,6 +5517,1123 @@
 //Callback registration function.
 void wifi_apAuthEvent_callback_register(wifi_apAuthEvent_callback callback_proc);
 
+typedef enum {
+        WIFI_EVENT_CHANNELS_CHANGED,
+        WIFI_EVENT_DFS_RADAR_DETECTED
+} wifi_chan_eventType_t;
+
+typedef void (*wifi_chan_eventCB_t)(UINT radioIndex, wifi_chan_eventType_t event, UCHAR channel);
+
+typedef enum {
+        CHAN_STATE_AVAILABLE = 1,
+        CHAN_STATE_DFS_NOP_FINISHED,
+        CHAN_STATE_DFS_NOP_START,
+        CHAN_STATE_DFS_CAC_START,
+        CHAN_STATE_DFS_CAC_COMPLETED
+} wifi_channelState_t;
+
+typedef struct _wifi_channelMap_t {
+        INT ch_number;
+        wifi_channelState_t ch_state;
+} wifi_channelMap_t;
+
+/* wifi_getRadioChannels() function */
+/*
+ * Description: This function returns a map of current states of each possible channel for given radio.
+ * The implementation must fill the map for each channel reported by wifi_getRadioPossibleChannels().
+ *
+ * Parameters :
+ * radioIndex - The index of the radio. First radio is index 0. 2nd radio is index 1 - type INT
+ * output_map - a pointer to an array of wifi_channelMap_t structures, preallocated by the caller.
+ *              This is where the output is written. If the item in the array is not used,
+ *              the "ch_number" should be set to 0.
+ * output_map_size - The size of the output_map array in array items.
+ *
+ * @return The status of the operation.
+ * @retval RETURN_OK if successful.
+ * @retval RETURN_ERR if any error is detected
+ *
+ * @execution Synchronous.
+ * @sideeffect None.
+ *
+ * @note This function must not suspend and must not invoke any blocking system
+ * calls. It should probably just send a message to a driver event handler task.
+ */
+INT wifi_getRadioChannels(INT radioIndex, wifi_channelMap_t *output_map, INT output_map_size);
+
+INT wifi_chan_eventRegister(wifi_chan_eventCB_t event_cb);
+
+/**
+* @brief This function is to read the ACL mode.
+*
+* @param[in]  apIndex             Access Point index
+* @param[out] output_filterMode   Mac Address control mode
+*
+* @return The status of the operation
+* @retval RETURN_OK if successful
+* @retval RETURN_ERR if any error is detected
+*
+* @execution Synchronous
+* @sideeffect None
+*
+* @note This function must not suspend and must not invoke any blocking system
+* calls. It should probably just send a message to a driver event handler task.
+*
+*/
+INT wifi_getApMacAddressControlMode(INT apIndex, INT *output_filterMode);
+
+/**
+* @brief Deletes all Device MAC address from the Access control filter list.
+*
+* @param[in]  apIndex           Access Point index
+*
+* @return The status of the operation
+* @retval RETURN_OK if successful
+* @retval RETURN_ERR if any error is detected
+*
+* @execution Synchronous
+* @sideeffect None
+*
+*/
+INT wifi_delApAclDevices(INT apINdex);
+
+/**
+* @brief To read the run time ssid name.
+*
+* @param[in]  apIndex         Access Point index
+* @param[out] output_string   SSID name, to be returned
+*
+* @return The status of the operation
+* @retval RETURN_OK if successful
+* @retval RETURN_ERR if any error is detected
+*
+* @execution Synchronous
+* @sideeffect None
+*
+* @note This function must not suspend and must not invoke any blocking system
+* calls. It should probably just send a message to a driver event handler task.
+*
+*/
+INT wifi_getSSIDNameStatus(INT apIndex, CHAR *output_string);
+
+INT wifi_getApChannel(INT radioIndex,ULONG *output_ulong);
+
+/* @description Set the neighbor report capability to activated or deactivated,
+ * same as enabled or disabled.  The word "activated" is used here because
+ * that's what's used in the 802.11 specification.  When deactivate the
+ * gateway ignores a neighbor report request as defined in 802.11-2016 section
+ * 11.11.10.3.
+ *
+ * Reciept of the TR-181 Object
+ * Device.WiFi.AccessPoint.{i}.X_RDKCENTRAL-COM_NeighborReportActivated via
+ * TR-069 or WebPA causes this function to be called with the value of the
+ * Object.
+ *
+ * @param apIndex - AP Index the setting applies to.
+ * @param activate - True for activate false for deactivate.
+ * @return The status of the operation.
+ * @retval RETURN_OK if successful.
+ * @retval RETURN_ERR if any error is detected.
+ */
+INT wifi_setNeighborReportActivation(UINT apIndex, BOOL activate);
+
+/* @description Get the neighbor report capability of activated or deactivated,
+ * same as enabled or disabled.
+ *
+ * Reciept of the TR-181 Object
+ * Device.WiFi.AccessPoint.{i}.X_RDKCENTRAL-COM_NeighborReportActivated via
+ * TR-069 or WebPA causes this function to be called with the value of the
+ * Object.
+ *
+ * @param apIndex - AP Index the setting applies to.
+ * @param activate - True for activate false for deactivate.
+ * @return The status of the operation.
+ * @retval RETURN_OK if successful.
+ * @retval RETURN_ERR if any error is detected.
+ */
+INT wifi_getNeighborReportActivation(UINT apIndex, BOOL *activate);
+
+typedef struct _wifi_associated_dev_rate_info_rx_stats {
+        // rate table index see table above
+        UCHAR nss;                                      /**< 0 equals legacy protocolss (OFDM, CCK) 1 - n spatial stream (HT, VHT) */
+        UCHAR mcs;                                              /**< 0 - 7 (HT) - 9 (VHT) */
+        USHORT bw;                                      /**< 20, 40, 80, 160 ... (to be considered 5 , 10, 80+80) ... */
+        ULLONG flags;                           /**< Flag indicating data validation that HAS_BYTES, HAS_MSDUS, HAS_MPDUS, HAS_PPDUS, HAS_BW_80P80, HAS_RSSI_COMB, HAS_RSSI_ARRAY */
+        ULLONG bytes;                                   /**< number of bytes received for given rate */
+        ULLONG msdus;                                   /**< number of MSDUs received for given rate */
+        ULLONG mpdus;                                   /**< number of MPDUs received for given rate */
+        ULLONG ppdus;                                   /**< number of PPDUs received for given rate */
+        ULLONG retries;                         /**< number of retries received for given rate */
+        UCHAR rssi_combined;                    /**< Last RSSI received on give rate */
+        /* Per antenna RSSI (above noise floor) for all widths (primary,secondary)
+                -----------------------------------------------
+                | chain_num |  20MHz [pri20                   ]
+                |           |  40MHZ [pri20,sec20             ]
+                |           |  80MHz [pri20,sec20,sec40,      ]
+                |           | 160MHz [pri20,sec20,sec40,sec80 ]
+                -----------------------------------------------
+                |  1        |  rssi  [pri20,sec20,sec40,sec80 ]
+                |  ...      |  ...
+                |  8        |  rssi  [pri20,sec20,sec40,sec80 ]
+                ----------------------------------------------- */
+        UCHAR rssi_array[8][4];                 //<! 8=antennas, 4=20+20+40+80 extension rssi
+} wifi_associated_dev_rate_info_rx_stats_t;
+
+/* wifi_getApAssociatedDeviceRxStatsResult() function */
+/**
+* @brief Get the associated client per rate receive status.
+*
+* @param [in]  radioIndex          The index of radio array.
+* @param [in]  clientMacAddress    Client mac address UCHAR[6]
+* @param [out] stats_array         Client receive status
+* @param [out] output_array_size   The length of output array
+* @param [out] handle              Status validation handle used to determine reconnects;
+*                                  increases for every association.
+*
+* @return The status of the operation
+* @retval RETURN_OK if successful
+* @retval RETURN_ERR if any error is detected
+*
+* @execution Synchronous
+* @sideeffect None
+*
+* @note This function must not suspend and must not invoke any blocking system
+* calls. It should probably just send a message to a driver event handler task.
+*
+*/
+INT wifi_getApAssociatedDeviceRxStatsResult(INT radioIndex, mac_address_t *clientMacAddress, wifi_associated_dev_rate_info_rx_stats_t **stats_array, UINT *output_array_size, ULLONG *handle);
+
+typedef struct _wifi_associated_dev_rate_info_tx_stats {
+        // rate table index see table above
+        UCHAR nss;                                      /**< 0 equals legacy protocolss (OFDM, CCK) 1 - n spatial stream (HT, VHT) */
+        UCHAR mcs;                                              /**< 0 - 7 (HT) - 9 (VHT) */
+        USHORT bw;                                      /**< 20, 40, 80, 160 ... (to be considered 5 , 10, 80+80) ... */
+        ULLONG flags;                           /**< Flag indicating data validation that HAS_BYTES, HAS_MSDUS, HAS_MPDUS, HAS_PPDUS, HAS_BW_80P80, HAS_RSSI_COMB, HAS_RSSI_ARRAY */
+        ULLONG bytes;                                   /**< number of bytes transmitted for given rate */
+        ULLONG msdus;                                   /**< number of MSDUs transmitted for given rate */
+        ULLONG mpdus;                                   /**< number of MPDUs transmitted for given rate */
+        ULLONG ppdus;                                   /**< number of PPDUs transmitted for given rate */
+        ULLONG retries;                         /**< number of transmittion retries for given rate */
+        ULLONG attempts;                                /**< number of attempts trying transmitt on given rate */
+} wifi_associated_dev_rate_info_tx_stats_t;
+
+/**
+* @brief Get the associated client per rate transmission status.
+*
+* @param [in]  radioIndex          The index of radio array.
+* @param [in]  clientMacAddress    Client mac address UCHAR[6]
+* @param [out] stats_array         Client transmission status
+* @param [out] output_array_size   The length of output array
+* @param [out] handle              Status validation handle used to determine reconnects;
+*                                  increases for every association.
+*
+* @return The status of the operation
+* @retval RETURN_OK if successful
+* @retval RETURN_ERR if any error is detected
+*
+* @execution Synchronous
+* @sideeffect None
+*
+* @note This function must not suspend and must not invoke any blocking system
+* calls. It should probably just send a message to a driver event handler task.
+*
+*/
+
+INT wifi_getApAssociatedDeviceTxStatsResult(INT radioIndex, mac_address_t *clientMacAddress, wifi_associated_dev_rate_info_tx_stats_t **stats_array, UINT *output_array_size, ULLONG *handle);
+
+typedef struct _wifi_rssi_snapshot {
+        UCHAR  rssi[4];                                 /**< Last 4 RSSI frames received */
+        UCHAR  time_s[4];                                  /**< Time of when last 4 RSSI were received */
+        USHORT count;                                      /**< Sequence numer of received managemant (bcn, ack) frames  */
+} wifi_rssi_snapshot_t;
+
+typedef struct _wifi_associated_dev_stats {
+        ULLONG  cli_rx_bytes;                           /**< The total number of bytes received from the client device, including framing characters. */
+        ULLONG  cli_tx_bytes;                           /**< The total number of bytes transmitted to the client device, including framing characters. */
+        ULLONG  cli_rx_frames;                          /**< The total number of frames received from the client */
+        ULLONG  cli_tx_frames;                          /**< The total number of frames transmitted to the client */
+        ULLONG  cli_rx_retries;                         /**< Number of rx retries */
+        ULLONG  cli_tx_retries;                         /**< Number of tx retries. cli_Retransmissions */
+        ULLONG  cli_rx_errors;                          /**< Number of numer of rx error */
+        ULLONG  cli_tx_errors;                          /**< Number of tx errors */
+        double  cli_rx_rate;                                    /**< average rx data rate used */
+        double  cli_tx_rate;                                    /**< average tx data rate used} wifi_associated_dev_t; */
+        wifi_rssi_snapshot_t cli_rssi_bcn;      /**< RSSI from last 4 beacons received (STA) */
+        wifi_rssi_snapshot_t cli_rssi_ack;      /**< RSSI from last 4 ack received     (AP) */
+} wifi_associated_dev_stats_t;
+
+/**
+* @brief Get the associated device  status.
+*
+* @param [in]  apIndex               The index of access point array
+* @param [in]  clientMacAddress      client mac address UCHAR[6]
+* @param [out] associated_dev_stats  Associated device status
+* @param [in]  handle                Status validation handle used to determine reconnects;
+*                                    increases for every association
+*
+* @return The status of the operation
+* @retval RETURN_OK if successful
+* @retval RETURN_ERR if any error is detected
+*
+* @execution Synchronous
+* @sideeffect None
+*
+* @note This function must not suspend and must not invoke any blocking system
+* calls. It should probably just send a message to a driver event handler task.
+*
+*/
+INT wifi_getApAssociatedDeviceStats(INT apIndex, mac_address_t *clientMacAddress, wifi_associated_dev_stats_t *associated_dev_stats, ULLONG *handle);
+
+typedef struct _wifi_associated_dev2
+{
+        mac_address_t cli_MACAddress;           /**< The MAC address of an associated device. */
+        CHAR  cli_IPAddress[64];                /**< IP of the associated device */
+        BOOL  cli_AuthenticationState; /**< Whether an associated device has authenticated (true) or not (false). */
+        UINT  cli_LastDataDownlinkRate; /**< The data transmit rate in kbps that was most recently used for transmission from the access point to the associated device. */
+        UINT  cli_LastDataUplinkRate;   /**< The data transmit rate in kbps that was most recently used for transmission from the associated device to the access point. */
+        INT   cli_SignalStrength;               /**< An indicator of radio signal strength of the uplink from the associated device to the access point, measured in dBm, as an average of the last 100 packets received from the device. */
+        UINT  cli_Retransmissions;      /**< The number of packets that had to be re-transmitted, from the last 100 packets sent to the associated device. Multiple re-transmissions of the same packet count as one. */
+        BOOL  cli_Active;                               /**<    boolean -       Whether or not this node is currently present in the WiFi AccessPoint network. */
+
+        CHAR  cli_OperatingStandard[64];        /**< Radio standard the associated Wi-Fi client device is operating under. Enumeration of: */
+        CHAR  cli_OperatingChannelBandwidth[64];        /**< The operating channel bandwidth of the associated device. The channel bandwidth (applicable to 802.11n and 802.11ac specifications only). Enumeration of: */
+        INT   cli_SNR;          /**< A signal-to-noise ratio (SNR) compares the level of the Wi-Fi signal to the level of background noise. Sources of noise can include microwave ovens, cordless phone, bluetooth devices, wireless video cameras, wireless game controllers, fluorescent lights and more. It is measured in decibels (dB). */
+        CHAR  cli_InterferenceSources[64]; /**< Wi-Fi operates in two frequency ranges (2.4 Ghz and 5 Ghz) which may become crowded other radio products which operate in the same ranges. This parameter reports the probable interference sources that this Wi-Fi access point may be observing. The value of this parameter is a comma seperated list of the following possible sources: eg: MicrowaveOven,CordlessPhone,BluetoothDevices,FluorescentLights,ContinuousWaves,Others */
+        ULONG cli_DataFramesSentAck;    /**< The DataFramesSentAck parameter indicates the total number of MSDU frames marked as duplicates and non duplicates acknowledged. The value of this counter may be reset to zero when the CPE is rebooted. Refer section A.2.3.14 of CableLabs Wi-Fi MGMT Specification. */
+        ULONG cli_DataFramesSentNoAck;  /**< The DataFramesSentNoAck parameter indicates the total number of MSDU frames retransmitted out of the interface (i.e., marked as duplicate and non-duplicate) and not acknowledged, but does not exclude those defined in the DataFramesLost parameter. The value of this counter may be reset to zero when the CPE is rebooted. Refer section A.2.3.14 of CableLabs Wi-Fi MGMT Specification. */
+        ULONG cli_BytesSent;    /**< The total number of bytes transmitted to the client device, including framing characters. */
+        ULONG cli_BytesReceived;        /**< The total number of bytes received from the client device, including framing characters. */
+        INT   cli_RSSI; /**< The Received Signal Strength Indicator, RSSI, parameter is the energy observed at the antenna receiver for transmissions from the device averaged over past 100 packets recevied from the device. */
+        INT   cli_MinRSSI;      /**< The Minimum Received Signal Strength Indicator, RSSI, parameter is the minimum energy observed at the antenna receiver for past transmissions (100 packets). */
+        INT   cli_MaxRSSI;      /**< The Maximum Received Signal Strength Indicator, RSSI, parameter is the energy observed at the antenna receiver for past transmissions (100 packets). */
+        UINT  cli_Disassociations;      /**< This parameter  represents the total number of client disassociations. Reset the parameter evey 24hrs or reboot */
+        UINT  cli_AuthenticationFailures;       /**< This parameter indicates the total number of authentication failures.  Reset the parameter evey 24hrs or reboot */
+
+        ULLONG   cli_Associations;      /**<  Stats handle used to determine reconnects; increases for every association (stat delta calcualtion) */
+} wifi_associated_dev2_t;
+
+/**
+* @brief The function  provides a list of the devices currently associated with the access point.
+*
+* HAL funciton should allocate an data structure array, and return to caller with "associated_dev_array".
+* Device.WiFi.AccessPoint.{i}.AssociatedDevice.{i}.
+*
+* @param[in] apIndex                Access Point index
+* @param[in] associated_dev_array   Associated device array, to be returned
+* @param[in] output_array_size      Array size, to be returned
+*
+* @return The status of the operation
+* @retval RETURN_OK if successful
+* @retval RETURN_ERR if any error is detected
+*
+* @execution Synchronous
+* @sideeffect None
+*
+* @note This function must not suspend and must not invoke any blocking system
+* calls. It should probably just send a message to a driver event handler task.
+*
+*/
+
+INT wifi_getApAssociatedDeviceDiagnosticResult2(INT apIndex, wifi_associated_dev2_t **associated_dev_array, UINT *output_array_size); //Tr181
+
+typedef struct _wifi_channelStats {
+        INT  ch_number;                                         /**< each channel is only 20MHz bandwidth */
+        BOOL ch_in_pool;                                /**< If ch_in_pool is false, driver do not need to scan this channel */
+        INT  ch_noise;                                  /**< this is used to return the average noise floor in dbm */
+        BOOL ch_radar_noise;                            /**< if ch_number is in DFS channel, this is used to return if radar signal is present on DFS channel (5G only) */
+        INT  ch_max_80211_rssi;                         /**< max RSSI from the neighbor AP in dbm on this channel. */
+        INT  ch_non_80211_noise;                        /**< average non 802.11 noise */
+        INT  ch_utilization;                            /**< this is used to return the 802.11 utilization in percent */
+        ULLONG ch_utilization_total; /**<  Total time radio spent receiveing or transmitting on that channel (ch_utilization_active) */
+        ULLONG ch_utilization_busy; /**<  Time radio detected that channel was busy (Busy = Rx + Tx + Interference) */
+        ULLONG ch_utilization_busy_tx; /**<  Time time radio spent transmitting on channel */
+        ULLONG ch_utilization_busy_rx; /**<  Time radio spent receiving on channel (Rx = Rx_obss + Rx_self + Rx_errr (self and obss errors) */
+        ULLONG ch_utilization_busy_self; /**< Time radio spend receiving on channel from its own connected clients */
+        ULLONG ch_utilization_busy_ext; /**< Time radio detected that extended channel was busy (40MHz extention channel busy */
+} wifi_channelStats_t;                                  //<!This data structure is for each channel
+
+//SURVEY CHANNEL
+/* wifi_getWifiChannelStats() function */
+/**
+* @brief Get the channels utilization status.
+*
+* @param[in]      radioIndex                      The index of the radio
+* @param[in, out] input_output_channelStats_array The array initially filled with requested channel numbers.
+*                                                 The same array is used as an output with channel statistics
+*                                                 details. Data for each channel must be written to the corresponding
+*                                                 element of the array. When array_size = 0, the API returns ONCHAN
+*                                                 stats in a single wifi_channelStats_t element.
+* @param[out]     array_size                      The length of the output array
+*
+*
+* @return The status of the operation
+* @retval RETURN_OK if successful
+* @retval RETURN_ERR if any error is detected
+*
+* @execution Synchronous
+* @sideeffect None
+*
+* @note This function must not suspend and must not invoke any blocking system
+* calls. It should probably just send a message to a driver event handler task.
+*
+*/
+//Get the basic Radio channel traffic static info
+INT wifi_getRadioChannelStats(INT radioIndex, wifi_channelStats_t *input_output_channelStats_array, INT array_size);
+
+typedef enum
+{
+    WIFI_RADIO_SCAN_MODE_NONE = 0,
+    WIFI_RADIO_SCAN_MODE_FULL,
+    WIFI_RADIO_SCAN_MODE_ONCHAN,
+    WIFI_RADIO_SCAN_MODE_OFFCHAN,
+    WIFI_RADIO_SCAN_MODE_SURVEY
+} wifi_neighborScanMode_t;
+
+/**
+* @brief This API initates the scanning.
+*
+* @param[in]  apIndex       The index of access point array.
+* @param[out] scan_mode     Scan modes.
+* @param[out] dwell_time    Amount of time spent on each channel in the hopping sequence.
+* @param[out] chan_num      The channel number.
+* @param[out] chan_list     List of channels.
+*
+* @return The status of the operation
+* @retval RETURN_OK if successful
+* @retval RETURN_ERR if any error is detected
+*
+* @execution Synchronous
+* @sideeffect None
+*
+* @note This function must not suspend and must not invoke any blocking system
+* calls. It should probably just send a message to a driver event handler task.
+*
+*/
+INT wifi_startNeighborScan(INT apIndex, wifi_neighborScanMode_t scan_mode, INT dwell_time, UINT chan_num, UINT *chan_list);
+
+/**
+* @brief Returns the Wifi scan status.
+*
+* @param[in]  radioIndex           Radio index
+* @param[out] neighbor_ap_array    Neighbour access point info to be returned
+* @param[out] output_array_size    Length of the output array.
+*
+* @return The status of the operation
+* @retval RETURN_OK if successful
+* @retval RETURN_ERR if any error is detected
+*
+* @execution Synchronous
+* @sideeffect None
+*
+* @note This function must not suspend and must not invoke any blocking system
+* calls. It should probably just send a message to a driver event handler task.
+*
+*/
+INT wifi_getNeighboringWiFiStatus(INT radioIndex, wifi_neighbor_ap2_t **neighbor_ap_array, UINT *output_array_size); //Mesh
+
+/**
+ * @brief Wifi Steering Event Types
+ * These are the different steering event types that are sent by the wifi_hal
+ * steering library.
+ */
+typedef enum {
+    WIFI_STEERING_EVENT_PROBE_REQ           = 1,    /**< Probe Request Event                             */
+    WIFI_STEERING_EVENT_CLIENT_CONNECT,             /**< Client association completed successfully Event */
+    WIFI_STEERING_EVENT_CLIENT_DISCONNECT,          /**< Client Disconnect Event                         */
+    WIFI_STEERING_EVENT_CLIENT_ACTIVITY,            /**< Client Active Change Event                      */
+    WIFI_STEERING_EVENT_CHAN_UTILIZATION,           /**< Channel Utilization Event                       */
+    WIFI_STEERING_EVENT_RSSI_XING,                  /**< Client RSSI Crossing Event                      */
+    WIFI_STEERING_EVENT_RSSI,                       /**< Instant Measurement Event                       */
+    WIFI_STEERING_EVENT_AUTH_FAIL                   /**< Client Auth Failure Event                       */
+} wifi_steering_eventType_t;
+
+/**
+ * @brief Probe Request Event Data
+ * This data is provided with @b WIFI_STEERING_EVENT_PROBE_REQ
+ */
+typedef struct {
+    mac_address_t                   client_mac;     /**< Client MAC Address         */
+    UINT                            rssi;           /**< RSSI of probe frame        */
+    BOOL                            broadcast;      /**< True if broadcast probe    */
+    BOOL                            blocked;        /**< True if response blocked   */
+} wifi_steering_evProbeReq_t;
+
+/**
+ * @brief STA datarate information
+ * These are STA capabilities values
+ */
+typedef struct {
+    UINT                            maxChwidth;         /**< Max bandwidth supported                */
+    UINT                            maxStreams;         /**< Max spatial streams supported          */
+    UINT                            phyMode;            /**< PHY Mode supported                     */
+    UINT                            maxMCS;             /**< Max MCS  supported                     */
+    UINT                            maxTxpower;         /**< Max TX power supported                 */
+    UINT                            isStaticSmps;       /**< Operating in Static SM Power Save Mode */
+    UINT                            isMUMimoSupported;  /**< Supports MU-MIMO                       */
+} wifi_steering_datarateInfo_t;
+
+typedef struct {
+    BOOL                            linkMeas;           /**< Supports link measurement      */
+    BOOL                            neighRpt;           /**< Supports neighbor reports      */
+    BOOL                            bcnRptPassive;      /**< Supports Passive 11k scans     */
+    BOOL                            bcnRptActive;       /**< Supports Active 11k scans      */
+    BOOL                            bcnRptTable;        /**< Supports beacon report table   */
+    BOOL                            lciMeas;            /**< Supports LCI measurement       */
+    BOOL                            ftmRangeRpt;        /**< Supports FTM Range report      */
+} wifi_steering_rrmCaps_t;
+
+/**
+ * @brief Client Connect Event Data
+ * This data is provided with @b WIFI_STEERING_EVENT_CLIENT_CONNECT
+ */
+typedef struct {
+    mac_address_t                   client_mac;     /**< Client MAC Address                     */
+    UINT                            isBTMSupported; /**< Client supports BSS TM                 */
+    UINT                            isRRMSupported; /**< Client supports RRM                    */
+    BOOL                            bandCap2G;      /**< Client is 2.4GHz capable               */
+    BOOL                            bandCap5G;      /**< Client is 5GHz capable                 */
+    wifi_steering_datarateInfo_t    datarateInfo;   /**< Client supported datarate information  */
+    wifi_steering_rrmCaps_t         rrmCaps;        /**< Client supported RRM capabilites       */
+} wifi_steering_evConnect_t;
+
+/**
+ * @brief Wifi Disconnect Sources
+ *
+ * These are the possible sources of a wifi disconnect.
+ * If the disconnect was initiated by the client, then @b DISCONNECT_SOURCE_REMOTE
+ * should be used.
+ * If initiated by the local AP, then @b DISCONNECT_SOURCE_LOCAL should be used.
+ * If this information is not available, then @b DISCONNECT_SOURCE_UNKNOWN should be used.
+ */
+typedef enum {
+    DISCONNECT_SOURCE_UNKNOWN               = 0,    /**< Unknown source             */
+    DISCONNECT_SOURCE_LOCAL,                        /**< Initiated locally          */
+    DISCONNECT_SOURCE_REMOTE                        /**< Initiated remotely         */
+} wifi_disconnectSource_t;
+
+/**
+ * @brief Wifi Disconnect Types
+ * These are the types of wifi disconnects.
+ */
+typedef enum {
+    DISCONNECT_TYPE_UNKNOWN                 = 0,    /**< Unknown type               */
+    DISCONNECT_TYPE_DISASSOC,                       /**< Disassociation             */
+    DISCONNECT_TYPE_DEAUTH                          /**< Deauthentication           */
+} wifi_disconnectType_t;
+
+/**
+ * @brief Client Disconnect Event Data
+ * This data is provided with @b WIFI_STEERING_EVENT_CLIENT_DISCONNECT
+ */
+typedef struct {
+    mac_address_t                   client_mac;     /**< Client MAC Address         */
+    UINT                            reason;         /**< Reason code of disconnect  */
+    wifi_disconnectSource_t         source;         /**< Source of disconnect       */
+    wifi_disconnectType_t           type;           /**< Disconnect Type            */
+} wifi_steering_evDisconnect_t;
+
+/**
+ * @brief Client Activity Change Event Data
+ * This data is provided with @b WIFI_STEERING_EVENT_CLIENT_ACTIVITY
+ */
+typedef struct {
+    mac_address_t                   client_mac;     /**< Client MAC Address         */
+    BOOL                            active;         /**< True if client is active   */
+} wifi_steering_evActivity_t;
+
+/**
+ * @brief Channel Utilization Event Data
+ * This data is provided with @b WIFI_STEERING_EVENT_CHAN_UTILIZATION
+ */
+typedef struct {
+    UINT                            utilization;    /**< Channel Utilization 0-100  */
+} wifi_steering_evChanUtil_t;
+
+/**
+ * @brief RSSI Crossing Values
+ * These are the RSSI crossing values provided in RSSI crossing events
+ */
+typedef enum {
+    WIFI_STEERING_RSSI_UNCHANGED            = 0,    /**< RSSI hasn't crossed        */
+    WIFI_STEERING_RSSI_HIGHER,                      /**< RSSI went higher           */
+    WIFI_STEERING_RSSI_LOWER                        /**< RSSI went lower            */
+} wifi_steering_rssiChange_t;
+
+/**
+ * @brief Client RSSI Crossing Event Data
+ * This data is provided with @b WIFI_STEERING_EVENT_RSSI_XING
+ */
+typedef struct {
+    mac_address_t                   client_mac;     /**< Client MAC Address         */
+    UINT                            rssi;           /**< Clients current RSSI       */
+    wifi_steering_rssiChange_t      inactveXing;    /**< Inactive threshold Value   */
+    wifi_steering_rssiChange_t      highXing;       /**< High threshold Value       */
+    wifi_steering_rssiChange_t      lowXing;        /**< Low threshold value        */
+} wifi_steering_evRssiXing_t;
+
+/**
+ * @brief Client RSSI Measurement Event Data
+ * This data is provided with @b WIFI_STEERING_EVENT_RSSI, which is sent in
+ * response to a requset for the client's current RSSI measurement
+ */
+typedef struct {
+    mac_address_t                   client_mac;     /**< Client MAC Address         */
+    UINT                            rssi;           /**< Clients current RSSI       */
+} wifi_steering_evRssi_t;
+
+/**
+ * @brief Auth Failure Event Data
+ * This data is provided with @b WIFI_STEERING_EVENT_AUTH_FAIL
+ */
+typedef struct {
+    mac_address_t                   client_mac;     /**< Client MAC Address         */
+    UINT                            rssi;           /**< RSSI of auth frame         */
+    UINT                            reason;         /**< Reject Reason              */
+    BOOL                            bsBlocked;      /**< True if purposely blocked  */
+    BOOL                            bsRejected;     /**< True if rejection sent     */
+} wifi_steering_evAuthFail_t;
+
+/**
+ * @brief Wifi Steering Event
+ * This is the data containing a single steering event.
+ */
+typedef struct {
+    wifi_steering_eventType_t       type;           /**< Event Type                 */
+    INT                             apIndex;        /**< apIndex event is from      */
+    ULLONG                          timestamp_ms;   /**< Optional: Event Timestamp  */
+    union {
+        wifi_steering_evProbeReq_t      probeReq;   /**< Probe Request Data         */
+        wifi_steering_evConnect_t       connect;    /**< Client Connect Data        */
+        wifi_steering_evDisconnect_t    disconnect; /**< Client Disconnect Data     */
+        wifi_steering_evActivity_t      activity;   /**< Client Active Change Data  */
+        wifi_steering_evChanUtil_t      chanUtil;   /**< Channel Utilization Data   */
+        wifi_steering_evRssiXing_t      rssiXing;   /**< Client RSSI Crossing Data  */
+        wifi_steering_evRssi_t          rssi;       /**< Client Measured RSSI Data  */
+        wifi_steering_evAuthFail_t      authFail;   /**< Auth Failure Data          */
+    } data;
+} wifi_steering_event_t;
+
+/**
+ * @brief Wifi Steering Event Callback Definition
+ *
+ * This is the definition of the event callback provided when upper layer
+ * registers for steering events.
+ *
+ * @warning the @b event passed to the callback is not dynamically
+ * allocated the call back function handler must allocate wifi_steering_event_t
+ * and copy the "event" into that
+ */
+typedef void (*wifi_steering_eventCB_t)(UINT steeringgroupIndex, wifi_steering_event_t *event);
+
+/**
+ * @brief Register for Steering Event Callbacks.
+ *
+ * This is called by the upper layer to register for steering event
+ * callbacks.
+ *
+ * @param[in]  event_cb Event callback function pointer.
+ *
+ * @return RETURN_OK on success, RETURN_ERR on failure.
+ *
+ * @warning the @b event passed to the callback should be a dynamically
+ * allocated event which upper layer will free by calling wifi_steering_eventFree()
+ */
+INT wifi_steering_eventRegister(wifi_steering_eventCB_t event_cb);
+
+/**
+ * @brief Unregister for Steering Event Callbacks.
+ *
+ * This is called by the upper layer to stop receiving event callbacks.
+ *
+ * @return RETURN_OK on success, RETURN_ERR on failure
+ */
+INT wifi_steering_eventUnregister(void);
+
+/**
+ * @brief Configuration per apIndex
+ *
+ * This defines the configuration for each @b apIndex added to a steering
+ * group
+ *
+ * Channel utilization is to be sampled every @b utilCheckIntervalSec seconds,
+ * and after collecting $b utilAvgCount samples, the steering event
+ * @b WIFI_STEERING_EVENT_CHAN_UTILIZATION should be sent with the averaged value.
+ *
+ * Client active/inactive checking is done every @b inactCheckIntervalSec seconds
+ * and if a given client is idle/inactive for @b inactCheckThresholdSec seconds then
+ * it should be marked as inactive.  Whenever a client changes states between active
+ * and inactive, the steering event @b WIFI_STEERING_EVENT_CLIENT_ACTIVITY should be
+ * sent.
+ */
+typedef struct {
+    INT         apIndex;
+
+    UINT        utilCheckIntervalSec;   /**< Channel utilization check interval        */
+    UINT        utilAvgCount;           /**< Number of samples to average           */
+
+    UINT        inactCheckIntervalSec;  /**< Client inactive check internval        */
+    UINT        inactCheckThresholdSec; /**< Client inactive threshold              */
+} wifi_steering_apConfig_t;
+
+/**
+ * @brief Add a Steering Group.
+ *
+ * A steering group defines a group of apIndex's which can have steering done
+ * between them.
+ *
+ * @param[in] steeringgroupIndex  Wifi Steering Group index
+ * @param[in] cfg_2               2.4G apConfig
+ * @param[in] cfg_5               5G apConfig
+ *
+ * @return RETURN_OK on success, RETURN_ERR on failure
+ *
+ * @warning All apIndex's provided within a group must have the same SSID,
+ * encryption, and passphrase configured for steering to function properly.
+ *
+ * @note The hal need to allocate (no matter static or dynamic) to store those two config
+ * if cfg_2 and cfg_5 are NULL, this steering group will be removed
+ */
+INT wifi_steering_setGroup(UINT steeringgroupIndex, wifi_steering_apConfig_t *cfg_2, wifi_steering_apConfig_t *cfg_5);
+
+/**
+ * @brief Configuration per Client
+ *
+ * This defines the per-client, per-apIndex configuration settings.  The
+ * high water mark + low water mark pairs define RSSI ranges, in which
+ * given packet types (probe or auth) are responded to as long as the RSSI
+ * of the request packet is within the defined range.
+ *
+ * The RSSI crossings define thresholds which result in steering events
+ * being generated when a connected clients RSSI crosses above or below
+ * the given threshold.
+ *
+ * authRejectReason, when non-zero, results in auth requests being
+ * rejected with the given reason code.  When set to zero, auth requests
+ * that do not fall in the RSSI hwm+lwm range will be silently ignored.
+ *
+ * @see https://supportforums.cisco.com/document/141136/80211-association-status-80211-deauth-reason-codes
+ */
+typedef struct {
+    UINT        rssiProbeHWM;           /**< Probe response RSSI high water mark    */
+    UINT        rssiProbeLWM;           /**< Probe response RSSI low water mark     */
+    UINT        rssiAuthHWM;            /**< Auth response RSSI high water mark     */
+    UINT        rssiAuthLWM;            /**< Auth response RSSI low water mark      */
+    UINT        rssiInactXing;          /**< Inactive RSSI crossing threshold       */
+    UINT        rssiHighXing;           /**< High RSSI crossing threshold           */
+    UINT        rssiLowXing;            /**< Low RSSI crossing threshold            */
+    UINT        authRejectReason;       /**< Inactive RSSI crossing threshold       */
+} wifi_steering_clientConfig_t;
+
+/**
+ * @brief Add Client Config to apIndex.
+ *
+ * The upper layer calls this funciton to @b add/modify per-client configuration @p config
+ * of @p client_mac for @p apIndex
+ *
+ * @param[in] steeringgroupIndex   Wifi Steering Group index
+ * @param[in] apIndex              Accesspoint index the client config should be added to
+ * @param[in] client_mac           The Client's MAC address.
+ *                                 If client_mac is not there, the hal need to add record,
+ *                                 else, the hal need to update the config
+ * @param[in] config               The client configuration
+ *
+ * @return RETURN_OK on success, RETURN_ERR on failure
+ */
+INT wifi_steering_clientSet(
+                                UINT steeringgroupIndex,
+                                INT apIndex,
+                                mac_address_t client_mac,
+                                wifi_steering_clientConfig_t *config);
+
+/**
+ * @brief Remove Client Config from apIndex
+ *
+ * The upper layer calls this function to @b remove per-client configuration
+ * of @p client_mac from @p apIndex
+ *
+ * @param[in] steeringgroupIndex  Wifi Steering Group index
+ * @param[in] apIndex             Access point index, the client config to be removed.
+ * @param[in] client_mac          The Client's MAC address
+ *
+ * @return RETURN_OK on success, RETURN_ERR on failure
+ */
+INT wifi_steering_clientRemove(
+                                UINT steeringgroupIndex,
+                                INT apIndex,
+                                mac_address_t client_mac);
+
+/**
+ * @brief Initiate Instant Client RSSI Measurement.
+ *
+ * This initiates an instant client RSSI measurement.  The recommended method of
+ * performing this measurement is to send five NUL wifi frames to the client, and
+ * average the RSSI of the ACK frames returned.  This averaged RSSI value should
+ * be sent back using @b WIFI_STEERING_EVENT_RSSI steering event type.
+ * Instant measurement improves user experience by not reacting to false-positive
+ * RSSI crossings.
+ * If for some reason instant measurement is not supported, the function should
+ * return RETURN_ERR and set errno to @b ENOTSUP.
+ *
+ * @param[in]  steeringgroupIndex  Wifi Steering Group index
+ * @param[in]  apIndex             Access point index, the client config should be added to
+ * @param[in]  client_mac          The Client's MAC address
+ *
+ * @return RETURN_OK on success, RETURN_ERR on failure.  Set errno to ENOTSUP if
+ * instant measurement is not supported
+ */
+INT wifi_steering_clientMeasure(
+                                UINT steeringgroupIndex,
+                                INT apIndex,
+                                mac_address_t client_mac);
+
+/**
+ * @brief Initiate a Client Disconnect.
+ *
+ * This is used by the upper layer to kick off a client, for steering purposes.
+ *
+ * @param[in]  steeringgroupIndex  Wifi Steering Group index
+ * @param[in]  apIndex             The access point index, the client config should be added to
+ * @param[in]  client_mac          The Client's MAC address
+ * @param[in]  type                Disconnect Type
+ * @param[in]  reason              Reason code to provide in deauth/disassoc frame.
+ *
+ * @return RETURN_OK on success, RETURN_ERR on failure
+ * @see https://supportforums.cisco.com/document/141136/80211-association-status-80211-deauth-reason-codes
+ */
+INT wifi_steering_clientDisconnect(
+                                UINT steeringgroupIndex,
+                                INT apIndex,
+                                mac_address_t client_mac,
+                                wifi_disconnectType_t type,
+                                UINT reason);
+
+typedef struct {
+    ULONG               tsf;    // 8 octet TSF timer value.
+    USHORT              duration;
+} wifi_BTMTerminationDuration_t;
+
+typedef struct {
+    CHAR                condensedStr[3];  // 2 char country code from do11CountryString.
+} wifi_CondensedCountryString_t;
+
+typedef struct {
+    USHORT              offset;
+    USHORT              interval;
+} wifi_TSFInfo_t;
+
+typedef struct {
+    UCHAR               preference;
+} wifi_BSSTransitionCandidatePreference_t;
+
+typedef struct {
+    USHORT              bearing;
+    UINT                dist;
+    USHORT              height;
+} wifi_Bearing_t;
+
+// Wide Bandwidth Channel Element, ID = 194.  802.11-2016 section 9.4.2.161.
+typedef struct {
+    UCHAR               bandwidth;
+    UCHAR               centerSeg0;
+    UCHAR               centerSeg1;
+} wifi_WideBWChannel_t;
+
+
+// HT Capabilities Element, ID = 45.  802.11-2016 section 9.4.2.56.
+typedef struct {
+
+    USHORT                  info;           // Bitfield where bit 0 is info[0] bit 0.
+    UCHAR                   ampduParams;
+    UCHAR                   mcs[16];        // Bitfield where bit 0 is mcs[0] bit 0.
+    USHORT                  extended;       // Bitfield where bit 0 is ele_HTExtendedCapabilities[0] bit 0.
+    UINT                    txBeamCaps;     // Bitfield where bit 0 is ele_TransmitBeamFormingCapabilities[0] bit 0.
+    UCHAR                   aselCaps;
+} wifi_HTCapabilities_t;
+
+// VHT Capabilities Element, ID = 191.  802.11-2016 section 9.4.2.158.
+typedef struct {
+    UINT                    info;
+    // The Supported VHT-MCS and NSS Set field is 64 bits long, but is broken
+    // into 4 16 bit fields for convenience.
+    USHORT                  mcs;
+    USHORT                  rxHighestSupportedRate;
+    USHORT                  txVHTmcs;
+    USHORT                  txHighestSupportedRate;
+} wifi_VHTCapabilities_t;
+
+// HT OperationElement, ID = 61, 802.11-2016 section 9.4.2.57.
+typedef struct {
+    UCHAR                   primary;
+    UCHAR                   opInfo[5];   // Bitfield where bit 0 is ele_HTOperationInfo[0] bit 0;
+    UCHAR                   mcs[16];
+} wifi_HTOperation_t;
+
+// VHT Operation Element, ID = 192.  802.11-2016 section 9.4.2.159.
+typedef struct {
+    wifi_WideBWChannel_t        opInfo;         // channel width, center of seg0, center of seg1
+    USHORT                      mcs_nss;        // Bit field.
+} wifi_VHTOperation_t;
+
+// Secondary Channel Offset Element, ID = 62, 802.11-2016 section
+// 9.4.2.20.
+typedef struct {
+    UCHAR                       secondaryChOffset;
+} wifi_SecondaryChannelOffset_t;
+
+// RM Enabled Capabilities Element, ID = 70, 802.11-2016 section
+// 9.4.2.45.
+typedef struct {
+    // This is a bit field defined by table 9-157.  Bit 0 for all of the
+    // capabilities is ele_RMEnabledCapabilities[5] bit 0.
+    UCHAR                       capabilities[5];
+} wifi_RMEnabledCapabilities_t;
+
+// Vendor Specific Element, ID = 221.  802.11-2016 section 9.4.2.26.
+typedef struct {
+    // 3 or 5 octet OUI depending on format; see 802.11-2016 section 9.4.1.32.
+    UCHAR           oui[5];
+    // Vendor specific content.
+    UCHAR           buff[MAX_VENDOR_SPECIFIC];
+} wifi_VendorSpecific_t;
+
+// Measurement Pilot Transmission Element, ID = 66, 802.11-2016 section
+// 9.4.2.42.
+typedef struct {
+    UCHAR                       pilot;
+    // Series of (sub)elements.  Table 9-155 only lists vendor specific.
+    wifi_VendorSpecific_t                       vendorSpecific;
+} wifi_MeasurementPilotTransmission_t;
+
+typedef struct {
+    bssid_t             bssid;
+    //  32 bit optional value, bit fileds are
+    //  b0, b1 for reachability
+    //  b2 security
+    //  b3 key scope
+    //  b4 to b9 capabilities
+    //  b10 mobility domain
+    //  b11 high troughput
+    //  b12 very high throughput
+    //  b13 ftm
+    //  b14 to b31 reserved
+    UINT                info;
+    UCHAR               opClass;
+    UCHAR               channel;
+    UCHAR               phyTable;
+    BOOL                tsfPresent;
+    wifi_TSFInfo_t      tsfInfo;
+    BOOL                condensedCountrySringPresent;
+    wifi_CondensedCountryString_t   condensedCountryStr;
+    BOOL                bssTransitionCandidatePreferencePresent;
+    wifi_BSSTransitionCandidatePreference_t         bssTransitionCandidatePreference;
+    BOOL                btmTerminationDurationPresent;
+    wifi_BTMTerminationDuration_t   btmTerminationDuration;
+    BOOL                bearingPresent;
+    wifi_Bearing_t      bearing;
+    BOOL                wideBandWidthChannelPresent;
+    wifi_WideBWChannel_t    wideBandwidthChannel;
+    BOOL                htCapsPresent;
+    wifi_HTCapabilities_t   htCaps;
+    BOOL                vhtCapsPresent;
+    wifi_VHTCapabilities_t  vbhtCaps;
+    BOOL                    htOpPresent;
+    wifi_HTOperation_t      htOp;
+    BOOL                    vhtOpPresent;
+    wifi_VHTOperation_t     vhtOp;
+    BOOL                    secondaryChannelOffsetPresent;
+    wifi_SecondaryChannelOffset_t   secondaryChannelOffset;
+    BOOL                    rmEnabledCapsPresent;
+    wifi_RMEnabledCapabilities_t    rmEnabledCaps;
+    BOOL                            msmtPilotTransmissionPresent;
+    wifi_MeasurementPilotTransmission_t     msmtPilotTransmission;
+    BOOL                    vendorSpecificPresent;
+    wifi_VendorSpecific_t   vendorSpecific;
+    ssid_t                  target_ssid;
+} wifi_NeighborReport_t;
+
+// BSS Transition Management Request Frame, 802.11-2016 section 9.6.14.9.
+typedef struct {
+    UCHAR               token;              /**< set by STA to relate reports */
+    UCHAR               requestMode;        /**< Requested instructions for the STA. */
+    USHORT              timer;
+    UCHAR               validityInterval;
+    // The optional fields may include:
+    // 1. BSS Termination Duration Subelement, ID = 4. 802.11-2016 Figure 9-300.
+    // 2. Session Information URL.
+    // 3. BSS Transition Candidate List Entries
+    wifi_BTMTerminationDuration_t    termDuration;
+    UCHAR               disassociationImminent;
+    USHORT              urlLen;
+    CHAR                url[MAX_URL_LEN];
+    UCHAR               numCandidates;
+    wifi_NeighborReport_t    candidates[MAX_CANDIDATES];
+} wifi_BTMRequest_t;
+
+/**
+ * @brief Set a BTM Request to a non-AP STA.  The callback register
+ * function should be called first so that the response can be handled by the
+ * application.
+ *
+ * @param apIndex; index of the vAP to send the request from.
+ * @param peerMACAddress; MAC address of the peer device to send the request to.
+ * @param in_struct; BTM Request Frame to send to the non-AP STA.
+ * @return The status of the operation.
+ * @retval RETURN_OK if successful.
+ * @retval RETURN_ERR if any error is detected.
+ *
+ * @execution Synchronous
+ * @sideeffect None
+ *
+ * @note This function must not suspend and must not invoke any blocking system
+ * calls.
+ */
+INT wifi_setBTMRequest(UINT apIndex,
+                        CHAR       *peerMac,
+                        wifi_BTMRequest_t *request);
+
+
+// 802.11k Beacon request & report structures and function prototypes
+#define MAX_REQUESTED_ELEMS     8
+#define MAX_CHANNELS            16
+
+typedef struct {
+    UCHAR               condition;
+    UCHAR               threshold;
+} wifi_BeaconReporting_t;
+
+typedef struct {
+    UCHAR               ids[MAX_REQUESTED_ELEMS];
+} wifi_RequestedElementIDS_t;
+
+typedef wifi_RequestedElementIDS_t  wifi_ExtdRequestedElementIDS_t;
+
+// AP Channel Report Element, ID = 51, 802.11-2016 section 9.4.2.36.
+typedef struct {
+    UCHAR               opClass;
+    UCHAR               channels[MAX_CHANNELS];
+} wifi_ChannelReport_t;
+
+// 802.11-2016 section 9.4.2.21.7
+typedef struct {
+    UCHAR               opClass;
+    UCHAR               channel;
+    USHORT              randomizationInterval;
+    USHORT              duration;
+    UCHAR               mode;
+    bssid_t             bssid;
+    BOOL                ssidPresent;
+    ssid_t              ssid;
+    BOOL                beaconReportingPresent;
+    wifi_BeaconReporting_t  beaconReporting;
+    BOOL                reportingRetailPresent;
+    UCHAR               reportingDetail;
+    BOOL                wideBandWidthChannelPresent;
+    wifi_WideBWChannel_t    wideBandwidthChannel;
+    BOOL                requestedElementIDSPresent;
+    wifi_RequestedElementIDS_t      requestedElementIDS;
+    BOOL                extdRequestedElementIDSPresent;
+    wifi_ExtdRequestedElementIDS_t  extdRequestedElementIDS;
+    BOOL                channelReportPresent;
+    wifi_ChannelReport_t    channelReport;
+    BOOL                vendorSpecificPresent;
+    wifi_VendorSpecific_t   vendorSpecific;
+    USHORT               numRepetitions;
+} wifi_BeaconRequest_t;
+
+/* @description Set a radio measurement (RM) beacon request.  Causes the
+ * request to be sent based on the information in the request parameter.
+ * Sent from the AP at apIndex.  Returns an error if a callback has not been
+ * registered for the AP.
+ *
+ * @param apIndex; index of the vAP to send the request from.
+ * @param peerMACAddress, MAC address of the peer device to send the request
+ *      to.  Must be an external device MAC address.
+ * @param in_request; pointer to a Beacon Report request structure.
+ * @param out_DialogToken; the token chosen by the STA for the requested
+ *      measurement(s);
+ * @return The status of the operation.
+ * @retval RETURN_OK if successful.
+ * @retval RETURN_ERR if any error is detected.  If the AP can determine that
+ *      the target device does not support Radio Measurement, then an error
+ *      is returned.
+ */
+INT wifi_setRMBeaconRequest(UINT apIndex,
+                             CHAR *peer,
+                             wifi_BeaconRequest_t *in_request,
+                             UCHAR *out_DialogToken);
+
+/* wifi_apDisassociatedDevice_callback() function */
+/**
+* @brief This call back will be invoked when new wifi client disassociates from Access Point.
+*
+* @param[in] apIndex          Access Point Index
+* @param[in] MAC                          MAC address of disassociated device
+* @param[in] event_type           type of disassociation, explicit or due to client inactivity
+*
+* @return The status of the operation
+* @retval RETURN_OK if successful
+* @retval RETURN_ERR if any error is detected
+*
+* @execution Synchronous
+* @sideeffect None
+*
+* @note This function must not suspend and must not invoke any blocking system
+* calls. It should probably just send a message to a driver event handler task.
+*
+*/
+typedef INT ( * wifi_apDisassociatedDevice_callback)(INT apIndex, char *MAC, INT event_type);
+
+/* wifi_apDisassociatedDevice_callback_register() function */
+/**
+* @brief Callback registration function.
+*
+* @param[in] callback_proc  wifi_apDisassociatedDevice_callback callback function
+*
+* @return The status of the operation
+* @retval RETURN_OK if successful
+* @retval RETURN_ERR if any error is detected
+*
+* @execution Synchronous
+* @sideeffect None
+*
+* @note This function must not suspend and must not invoke any blocking system
+* calls. It should probably just send a message to a driver event handler task.
+*
+*/
+void wifi_apDisassociatedDevice_callback_register(wifi_apDisassociatedDevice_callback callback_proc);
+
+typedef struct _wifi_client_associated_dev
+{
+        UCHAR MACAddress[6];                /**< The MAC address of an associated device. */
+        INT NetworkID;                      /**< Network ID */
+        INT connected;                      /**< If network is connected */
+        INT reason;
+        INT locally_generated;
+} wifi_client_associated_dev_t;
+
+typedef INT ( * wifi_client_event_callback)(INT apIndex, wifi_client_associated_dev_t *state);
+
+void wifi_client_event_callback_register(wifi_client_event_callback callback_proc);
+
+typedef struct wifi_sta_network {
+        int id;
+        char bridge[16]; /* valid for 4addr_multi_ap */
+        char ssid[32];
+        char psk[128];
+        char bssid[6]; /* 00:00:00:00:00:00 means any */
+        size_t ssid_len;
+        size_t psk_len;
+        int multi_ap;
+        char pairwise[64];
+        char proto[64];
+        char key_mgmt[64];
+        unsigned long flags; /* enum wifi_sta_network_flags */
+} wifi_sta_network_t;
+
+INT wifi_getSTANetworks(INT apIndex, wifi_sta_network_t **out_staNetworks_array, INT out_array_size, BOOL *out_scan_cur_freq);
+
+INT wifi_setSTANetworks(INT apIndex, wifi_sta_network_t **staNetworks_array, INT array_size, BOOL scan_cur_freq);
+
 //<< ------------------------------ wifi_ap_hal -----------------------
 
 #else
